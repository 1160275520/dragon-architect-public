% This is "sig-alternate.tex" V2.0 May 2012
% This file should be compiled with V2.5 of "sig-alternate.cls" May 2012
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.5 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.5) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V2.0 - May 2012

\documentclass{sig-alternate}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{url}

\newcommand{\TODO}[1]{{\color{red} TODO: #1}}
%\newcommand{\gametitle}{{\color{RoyalPurple} Dragon Architect}}
\newcommand{\gametitle}{{\emph{Dragon Architect}}}

\toappear{Submitted for review.}

\begin{document}
%
% --- Author Metadata here ---
%\conferenceinfo{Foundations of Digital Games (FDG)}{2015}
% \pdfinfo{
% /Title ()
% /Author (Aaron Bauer, Eric Butler, Zoran Popovic) 
% /Subject ()
% /Keywords ()
% }
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{\TODO{title}}

\numberofauthors{1}
\author{Anonymized}

% \numberofauthors{1} 
% \author{
% \alignauthor
% Aaron Bauer, Eric Butler, Zoran Popovi\'c\\
%        \affaddr{Center for Game Science}\\
%        \affaddr{Computer Science \& Engineering}\\
%        \affaddr{University of Washington}\\
%        \affaddr{Seattle, WA 98195}
%        \email{\{awb, edbutler\}@cs.washington.edu}
% }

\maketitle
\begin{abstract}
\TODO{abstract}
\end{abstract}
% TODO replace macros in abstract so we don't accidentally paste them into form

% A category with the (minimum) three required fields
\category{K.3.2}{Computers and Education}{Computer and Information Science Education -- Computer science education}

\terms{Design, Human Factors}

\keywords{Game-based learning; computational thinking; programming education}

\section{Introduction}
% TODO move these citations somewhere
%Despite the proliferation of these systems, little work has investigated how to design the structure or content of such systems. There have been surveys of both the systems themselves~\cite{guzdial2004programming, kelleher2005lowering} and of research involving these systems~\cite{salleh2013analysis, backlund2013educational}. Researchers have enumerated desirable properties for such systems~\cite{repenning2010scalable} discussed their design~\cite{powers2006tools}.
%Comparative studies of effective ways to present computer science concepts in these systems, however, have been largely absent. A meta-analysis by Ke~\cite{ke2009qualitative} found that existing empirical research is fragmented and called for a more systematic approach.

The past few years have seen many efforts to broaden the reach of computer science education and make it available, and accessible, to more students in more places. As the expansion of computer science education gathers momentum, we need more concrete data to guide the development of educational systems and curricula. Though researchers have created many educational programming environments~\cite{kelleher2005lowering} and done substantial work on educational games in general~\cite{backlund2013educational}, and educational programming tools in particular~\cite{salleh2013analysis}, there is a lack of systematic empirical work on how to build and use educational technology to teach computer science.

Teaching \emph{computational thinking} has been a focus of recent efforts to broaden the reach of computer science education, including those using block-based programming environments. In their review of recent literature on teaching computational thinking, Lye and Koh~\cite{lye2014review} use Brennan and Resnick's definition of computational thinking as consisting of \emph{concepts}, \emph{practices}, and \emph{perspectives}~\cite{brennan2012new}. Concepts are basic programming ideas (such as variables, conditionals, and loops), practices are the problem-solving strategies used while programming (such as ``being incremental and iterative'' or ``using abstraction and modularization''), and perspectives are the relationships with the wider technological world. Lye and Koh conclude that more research is needed on teaching computational thinking \emph{practices} in particular. How to \emph{directly} teach such skills in a block-based programming environment is an open problem. 

Investigating these questions depends on answers to broader research questions about effective methods of teaching in games. The structure of existing educational programming environments generally falls into one of two groups: (1) an open-ended setting with little to no direct guidance where players are intended to learn via exploration and from instructors or other members of the social community, or (2) a linear series of puzzles or exercises with substantial direct guidance, but little in the way of exploration of social interaction. Both methods have benefits, and exploring how to combine these designs leads to interesting questions and design challenges. An important method through which open-ended games can guide players in the social environment, and questions about how to foster such guidance in a programming game deserve special attention.

Our contributions are as follows: we survey research on teaching computational thinking in games and software systems and describe the open problems in that space, including how languages impact novices. We then survey and discuss related research problems in game-based learning. We are currently creating \gametitle{}, an educational, creativity sandbox game designed to investigate these questions. We describe design trade-offs and decisions in \gametitle{}, focusing on a few unsolved design obstacles: how to combine open-ended sandbox games with direct guidance, and how to encourage a social environment in a programming game. The focus of this paper is on the survey and discussion of open research problems in teaching computational thinking through games, and the design challenges and trade-offs encountered when building a game to tackle these problems, rather than our game per se. We think the problems we describe are relevant to anyone making educational games or systems that need to teach complex concepts and skills.

\section{Game Description}
Before we discuss open research problems and design challenges, we describe basic information about \gametitle{} to provide context for the discussion.
In \gametitle{}, players write code to control a dragon that builds 3D structures in a block world.
Our game, which has been in development since spring 2014, is played in a web browser.
Similar to other programming environments, the user interface is separated into two parts: an area where the player can assemble their code and a visualization of the 3D environment their code affects (see Figure~\ref{fig:overall}). 
The game uses the \emph{Unity} game engine~\cite{unity} for the 3D environment and the Blockly drag-and-drop programming library~\cite{blockly} for inputing code.

The visual language players use is a set of \emph{code blocks} that snap together to form programs. 
The player can move the dragon in three dimensions and have the dragon place and remove cubes of various colors. 
In addition to blocks that control the dragon directly, players can also make use of definite loops and procedures (see Figure~\ref{fig:toolbox}).
Given that syntax can be an obstacle for those new to programming~\cite{stefik2013syntax}, we chose to use a visual language as there is evidence visual languages are helpful to novices~\cite{whitley1997visual}.

As players progress through the game, they alternate between short sequences of puzzles with a specific goal and set of available code blocks and an open-ended sandbox.
The game begins with puzzles that introduce the idea of assembling and running code, as well as the code blocks for moving the dragon and placing cubes.
After that, the player can creatively experiment and build in the sandbox and complete other puzzle sequences to make more code blocks available, switching between sandbox and puzzles at any time. 
In this way, the language the player uses to write instructions for the dragon gradually expands as the player advances.

The popularity and uniquely broad appeal of \emph{Minecraft}~\cite{minecraft} motivated our use of a 3D grid world in which the player's programs could place cubes.
This choice also makes it natural to extend our game in the future with exploration, more complex interaction with the environment, or players working together in a shared world.
Our playtests with \gametitle{} have shown the premise of programming a dragon in a \emph{Minecraft}-like world appeals to younger players of all genders.
Common sandbox activities have included making the dragon travel very long distances, building big and impressive towers, and spelling one's name out of cubes.

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{images/toolbox-wide}
  \caption{The programming elements available in \gametitle{}, which include moving the dragon, placing blocks, definite loops, and procedure definitions.}
  \label{fig:toolbox}
\end{figure}


\begin{figure*}[t!]
  \centering
  \includegraphics[width=\textwidth]{images/overall-example}
  \caption{The player assembles code to control the dragon on the left side, and the dragon and world it inhabits are visualized on the right side. Only a few different code blocks are available to the player initially, and more are unlocked through completing guided puzzles.}
  \label{fig:overall}
\end{figure*}

\section{Research Questions}
\label{sec:research}

Our primary goal for \gametitle{} is to investigate questions in computer science education and game-based learning. 
Specifically, we are interested in exploring how to teach computational thinking skills and problem-solving strategies, and we are interested in exploring which programming languages best support novices in learning these skills. 
Investigating these questions requires answers to larger research questions on how an effective educational game should be structured.
Open-ended games and systems typically perform poorly at teaching complex concepts without instructors or other outside help, but linear, direct-guidance-based games and systems don't offer the engaging creative and social experiences that can be found in more open-ended settings.
In this section, we describe these research problems in detail along with design trade-offs related to investigating these problems.

\subsection{Teaching Computer Science}

\subsubsection{Computational Thinking}

% what is it
As discussed in the introduction, a major goal of our project is to explore methods of teaching computational thinking skills.
Many have studied how to increase the presence and effectiveness of computational thinking in computer science education (and education in general) (e.g., Barr and Stephenson~\cite{barr2011bringing}), and others have developed games to teach these ideas~\cite{weintrop2013robobuilder, kazimoglu2012serious}.
A recent review of the literature on teaching computational thinking found that additional research is needed~\cite{lye2014review}.
Furthermore, we believe there is not enough empirical work on using educational games to teach computational thinking skills. 

\gametitle{}'s design is structured to encourage and require use of computational thinking skills.
Like many programming games, we force the player to automate tasks that they are used to performing manually (in this case, the construction of 3D block structures).
As the player sets more sophisticated goals, modularity becomes important (e.g., putting the building of a wall into a procedure) to keep the visual programming feasible. 

% how can we teach it directly?
As we cannot expect players to learn such complex skills simply by playing in an environment that requires those skills~\cite{mayer2004should}, we must address how to directly teach computational thinking skills.
One such skill is the identification and application of problem-solving strategies, which is a core component of computational thinking.
A great deal of recent education research suggests that ``curricula can model such strategies for students'' and that appropriate guidance, which in many cases consists of the capabilities afforded by a suitable computational environment, can ``enable students to learn to use these strategies independently''~\cite{report2010computational}.
Mayer and Wittrock call attention to the substantial evidence in the education literature for teaching what they call \emph{domain-specific thinking skills} and \emph{metacognitive skills}~\cite{mayer1996handbook}.
The former would include the ability to use a strategy like divide and conquer, and the latter would include knowing when and where to employ that strategy.
In both cases, Mayer and Wittrock describe studies (for non-computer science domains) that have shown teaching these skills directly can improve learning and performance. It is an open question whether this can be applied to teaching computational thinking in a game.

% teaching stategies like divide and conquer
One strategy we have focused on is \emph{divide and conquer}.
Our initial attempt to directly teach divide and conquer is to lead the player though a top-down deconstruction of building a large castle.
The player is presented with a single code block that builds an entire castle, but discovers the construction has a number of flaws. 
The next several puzzles each decompose some part of the flawed program in order to give the player a chance to repair it. 
For example, to enable the player to give the castle the correct number of walls and towers, the castle code block is split into a tower block and a wall block that the player uses to write a corrected castle procedure, as shown Figure~\ref{fig:decomp}. 
This part of \gametitle{} needs to be expanded and refined before it can be evaluated, and the larger question merits further attention. 

\begin{figure*}[th!]
  \centering
  \includegraphics[width=\textwidth]{images/decomp-code}
  \caption{The code required by a progression of levels demonstrating the strategy of divide and conquer. In A, the player uses a single code block to build an entire castle. Then, in B, the player is given an empty \texttt{FixedCastle} procedure, which they must fill with the appropriate number of wall and tower blocks. Finally, in C, the player is given a completed \texttt{FixedCastle} procedure and must fill in the \texttt{FixedTower} procedure as shown. The final completed castle is shown on the right.}
  \label{fig:decomp}
\end{figure*}

\section{Conclusion}


Though the number of educational programming tools and the amount of research done with them has increased dramatically, systematic empirical work has remained sparse.
In this paper, we discussed some open questions related to teaching computational thinking in games.
These included how to teach problem-solving strategies such as divide and conquer and which language semantics are suitable for novices.
We also discussed broader questions about learning in games.
Fully open, discovery-learning approaches common to games and educational software require a teacher or social environment to be effective for complex learning domains.
We described design trade-offs and unresolved obstacles in attempting to combine an open-ended game with structured direct teaching, as well as in attempting to bring benefits of social environments in multiplayer games to a programming game.
We used the ongoing design of our game, \gametitle{}, as a context for these discussions.
We hope to investigate several of these open questions with \gametitle{}, but believe these problems merit attention from the wider community.

% Comment out in submission version
%\section{Acknowledgments}
%\TODO{copy from CHI papers?}

\bibliographystyle{abbrv}
\bibliography{dragon-architect-vlhcc-2015} 
\end{document}
