% This is "sig-alternate.tex" V2.0 May 2012
% This file should be compiled with V2.5 of "sig-alternate.cls" May 2012
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.5 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.5) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V2.0 - May 2012

\documentclass{sig-alternate}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{url}

\newcommand{\TODO}[1]{{\color{red} TODO: #1}}
%\newcommand{\gametitle}{{\color{RoyalPurple} Dragon Architect}}
\newcommand{\gametitle}{{\emph{Dragon Architect}}}

\toappear{Submitted for review.}

\begin{document}
%
% --- Author Metadata here ---
\conferenceinfo{Blocks and Beyond}{2015}
\pdfinfo{
  /Title ()
  /Author (Aaron Bauer, Eric Butler, Zoran Popovic) 
  /Subject ()
  /Keywords ()
}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{\TODO{title}}

\numberofauthors{1} 
\author{
  \alignauthor
  Aaron Bauer, Eric Butler, Zoran Popovi\'c\\
  \affaddr{Center for Game Science}\\
  \affaddr{Computer Science \& Engineering}\\
  \affaddr{University of Washington}\\
  \affaddr{Seattle, WA 98195}
  \email{\{awb, edbutler\}@cs.washington.edu}
}

\maketitle
\begin{abstract}
\TODO{abstract}
\end{abstract}
% TODO replace macros in abstract so we don't accidentally paste them into form

% A category with the (minimum) three required fields
\category{K.3.2}{Computers and Education}{Computer and Information Science Education -- Computer science education}

\terms{Design, Human Factors}

\keywords{Block-based programming; computational thinking; programming education}

\section{Introduction}

Teaching \emph{computational thinking} has been a focus of recent efforts to broaden the reach of computer science education, including those using block-based programming environments. 
In their review of recent literature on teaching computational thinking, Lye and Koh~\cite{lye2014review} use Brennan and Resnick's definition of computational thinking as consisting of \emph{concepts}, \emph{practices}, and \emph{perspectives}~\cite{brennan2012new}. 
Concepts are basic programming ideas (such as variables, conditionals, and loops), practices are the problem-solving strategies used while programming (such as ``being incremental and iterative'' or ``using abstraction and modularization''), and perspectives are the relationships with the wider technological world. 
Lye and Koh conclude that more research is needed on teaching computational thinking \emph{practices} in particular. 
How to \emph{directly} teach such skills in is an open problem, no more so than in the context of a block-based programming environment. 

In this paper we propose investigating teaching computational practices in an educational block-based programming game called \emph{Dragon Architect}. 
We briefly discuss existing work on teaching computational thinking and the direct teaching of problem-solving strategies. 
We describe ways this might be attempted in \emph{Dragon Architect}, as well as ways we might evaluate such work. 

\section{Game Description}
\TODO{website, source code links}

Before we discuss teaching computational thinking, we describe basic information about \emph{Dragon Architect} to provide context for the discussion.
In \emph{Dragon Architect}, players write code to control a dragon that builds 3D structures in a block world.
Our game, which has been in development since spring 2014, is played in a web browser.
Similar to other programming environments, the user interface is separated into two parts: an area where the player can assemble their code and a visualization of the 3D environment their code affects (see Figure~\ref{fig:overall}). 
The game uses the \emph{Unity} game engine~\cite{unity} for the 3D environment and the Blockly drag-and-drop programming library~\cite{blockly} for inputing code.

The player can move the dragon in three dimensions and have the dragon place and remove cubes of various colors. 
In addition to blocks that control the dragon directly, players can also make use of definite loops and procedures (see Figure~\ref{fig:toolbox}).
As players progress through the game, they alternate between short sequences of puzzles with a specific goal and set of available code blocks and an open-ended sandbox.
The game begins with puzzles that introduce the idea of assembling and running code, as well as the code blocks for moving the dragon and placing cubes.
After that, the player can creatively experiment and build in the sandbox and complete other puzzle sequences to make more code blocks available, switching between sandbox and puzzles at any time. 
In this way, the language the player uses to write instructions for the dragon gradually expands as the player advances.

The popularity and uniquely broad appeal of \emph{Minecraft}~\cite{minecraft} motivated our use of a 3D grid world in which the player's programs could place cubes.
This choice also makes it natural to extend our game in the future with exploration, more complex interaction with the environment, or players working together in a shared world.
Our playtests with \emph{Dragon Architect} have shown the premise of programming a dragon in a \emph{Minecraft}-like world appeals to younger players of all genders.
Common sandbox activities have included making the dragon travel very long distances, building big and impressive towers, and spelling one's name out of cubes.

\begin{figure*}[t!]
  \centering
  \includegraphics[width=\textwidth]{images/overall-example}
  \caption{The player assembles code to control the dragon on the left side, and the dragon and world it inhabits are visualized on the right side. Only a few different code blocks are available to the player initially, and more are unlocked through completing guided puzzles.}
  \label{fig:overall}
\end{figure*}

\begin{figure}[htb]
  \centering
  \includegraphics[width=\columnwidth]{images/toolbox-wide}
  \caption{The programming elements available in \gametitle{}, which include moving the dragon, placing blocks, definite loops, and procedure definitions.}
  \label{fig:toolbox}
\end{figure}

\section{Teaching Computational Thinking Strategies}

% what is it
As discussed in the introduction, a major goal of our project is to explore methods of teaching computational thinking skills.
Many have studied how to increase the presence and effectiveness of computational thinking in computer science education (and education in general) (e.g., Barr and Stephenson~\cite{barr2011bringing}), and others have developed games to teach these ideas~\cite{weintrop2013robobuilder, kazimoglu2012serious}.
A recent review of the literature on teaching computational thinking found that additional research is needed~\cite{lye2014review}.
Furthermore, we believe there is not enough empirical work on using educational games to teach computational thinking skills. 

\gametitle{}'s design is structured to encourage and require use of computational thinking skills.
Like many programming games, we force the player to automate tasks that they are used to performing manually (in this case, the construction of 3D block structures).
As the player sets more sophisticated goals, modularity becomes important (e.g., putting the building of a wall into a procedure) to keep the visual programming feasible. 

% how can we teach it directly?
As we cannot expect players to learn such complex skills simply by playing in an environment that requires those skills~\cite{mayer2004should}, we must address how to directly teach computational thinking skills.
One such skill is the identification and application of problem-solving strategies, which is a core component of computational thinking.
A great deal of recent education research suggests that ``curricula can model such strategies for students'' and that appropriate guidance, which in many cases consists of the capabilities afforded by a suitable computational environment, can ``enable students to learn to use these strategies independently''~\cite{report2010computational}.
Mayer and Wittrock call attention to the substantial evidence in the education literature for teaching what they call \emph{domain-specific thinking skills} and \emph{metacognitive skills}~\cite{mayer1996handbook}.
The former would include the ability to use a strategy like divide and conquer, and the latter would include knowing when and where to employ that strategy.
In both cases, Mayer and Wittrock describe studies (for non-computer science domains) that have shown teaching these skills directly can improve learning and performance. It is an open question whether this can be applied to teaching computational thinking in a game.

% teaching stategies like divide and conquer
One strategy we have focused on is \emph{divide and conquer}.
Our initial attempt to directly teach divide and conquer is to lead the player though a top-down deconstruction of building a large castle.
The player is presented with a single code block that builds an entire castle, but discovers the construction has a number of flaws. 
The next several puzzles each decompose some part of the flawed program in order to give the player a chance to repair it. 
For example, to enable the player to give the castle the correct number of walls and towers, the castle code block is split into a tower block and a wall block that the player uses to write a corrected castle procedure, as shown Figure~\ref{fig:decomp}. 
This part of \gametitle{} needs to be expanded and refined before it can be evaluated, and the larger question merits further attention. 

\begin{figure*}[th!]
  \centering
  \includegraphics[width=\textwidth]{images/decomp-code}
  \caption{The code required by a progression of levels demonstrating the strategy of divide and conquer. In A, the player uses a single code block to build an entire castle. Then, in B, the player is given an empty \texttt{FixedCastle} procedure, which they must fill with the appropriate number of wall and tower blocks. Finally, in C, the player is given a completed \texttt{FixedCastle} procedure and must fill in the \texttt{FixedTower} procedure as shown. The final completed castle is shown on the right.}
  \label{fig:decomp}
\end{figure*}

\section{Conclusion}

\TODO{conclusion}

% Comment out in submission version
%\section{Acknowledgments}
%\TODO{copy from CHI papers?}

\bibliographystyle{abbrv}
\bibliography{dragon-architect-vlhcc-2015} 
\end{document}
